# 一种绘制有向图的方法

## 摘要

本文描述了一种用于绘制有向图的四遍算法。 

- 第一遍，找到最佳等级分配，通过使用网络单纯形算法。 

- 第二遍，减少交叉，结合新型权重函数和局部置换的迭代启发式算法为同一层级的顶点确定次序。

- 第三遍，寻找最佳坐标，构建节点和排序辅助图。
 
- 第四遍，通过计算样条来画边。 

该算法能够快速的画出美观的有向图。

## 1. 引言

绘制抽象图是一个活跃的研究领域，具有诸如程序和数据结构的可视化以及文档准备之类的应用。 
本文介绍了一种在平面中绘制有向图的技术。 目标是足够快地制作高质量的图纸以进行交互使用。 
这些算法是实际实现的基础[GNV1]。

### 1.1 美学标准

要制作图纸，有助于假设有向图具有总体流程或方向，例如从上到下（在本白皮书的大多数示例中假定）或从左到右。
可以在有限自动机的手工绘图中看到这样的流程，其中流程是从初始状态到最终状态，或者是从输入到输出的数据流图中。
该观察结果基于以下美学原理的用于绘制有向图的方法的集合：

- A1 在图中公开层次结构。特别是，如果可能，将边缘对准相同的大致方向。这有助于查找定向路径并突出显示源节点和宿节点。

- A2 避免不传达有关基础图的信息的视觉异常。例如，避免边缘交叉和急剧弯曲。

- A3 保持边缘短。这使得更容易找到相关节点，并有助于A2.

- A4 良好的对称性和平衡性。

这种美感在我们的算法中仅次于其他地方，无法同时优化所有这些美感。

例如，根据A1优选的节点的布置和边缘的取向可能迫使根据A2不期望的边缘交叉。此外，在计算上难以处理以最大程度地减少边缘交叉或查找子图具有对称性。

因此，我们做出一些简化的假设，并依靠启发式算法快速运行并在常见情况下进行良好的布局。

需要了解其他美学原理，请读者参考Eades和Tamassia [ET] 关于图形绘制算法的带注释书目。

### 1.2 问题描述

绘图算法的输入是属性图 G = (V, E) 可能带有环或者多条边。假设G是连通的，对于每个连接的组件可以单独列举。其属性如下:

xsize(v), ysize(v)      节点v外接边框的尺寸。
nodesep(G)              节点外接边框之间最小水平间隔。
randsep(G)              节点外接边框之间最小竖直间隔。
w(e)                    边e的权重，通常是1。权重代表边的重要程度，它被作为保持边短小和横向对齐的依据。

算法赋予每个节点v一个矩形区域的中心位于(x(v), y(v))， 并且赋予每条边一个B-Spline控制序列点(x0(e), y0(e)),...,(xn(e), yn(e))。
虽然这些值都没有指定单位，通常用72单位/英寸的坐标系系统来实现。该布局系统会遵循美学标准A1-A4以及图本身的属性。
这些约束的细节会在后面章节介绍。

用户可以通过一种方式来限制布局，这种方式对于有时间线的图形或高亮显示来源和终止节点非常有用。
下一节描述算法的初始遍历将节点分配给离散等级0...Max_rank。相同离散等级的节点接收到相同Y坐标值。
用户可以提供集合Smax, Smin, S0, S1, ...,Sk 子集V。这些（可能是空集）顶点集必须共同放置在最大，最小或者相同离散级别。

### 1.3 相关工作

绘制图型使用Warfield最先提出使用启发式算法画有向图以减少交叉，Carpano、Sugiyama、Tagawa以及Toda等人也发现了类似的方法。
Di Battista和Tamassia提出了一种所有边指向同一方向的平面布局有向图的算法。本文算法是基于Warfield， Sugiyama等人工作之上的。

### 1.4 概述

图的绘制算法分为四步, 如下面伪代码。
第一步，将节点分布在离散的层级。
第二步，设定层级中节点的顺序避免边的交叉。
第三步，设定节点确切的布局坐标。
第四步，确定绘制边曲线的控制点。

~~~pasical
procedure draw_graph()
begin
    rank();
    ordering();
    position();
    make_splines();
end
~~~

本文的贡献在于: 
1. 使用网络单纯形算法高效的为节点指定层级
2. 使用一种优化的启发式算法减少边交叉
3. 为层级分配问题使用一种节点坐标计算方法
4. 一种指定曲线函数控制点的方法

(1)和(2)最先在绘图软件dag中实现[GNV1]。进一步的工作(3)和(4)被纳入dag的替代品dot中。
图1-2和1-3是dot的布局示例及其输入文件。

~~~dot
digraph world_dynamics {
    size="6,6";
    S8 -> 9; S24 -> 27; S24 -> 25; S1 -> 10; S1 -> 2; S35 -> 36;
    S35 -> 43; S30 -> 31; S30 -> 33; 9 -> 42; 9 -> T1; 25 -> T1;
    25 -> 26; 27 -> T24; 2 -> 3; 2 -> 16; 2 -> 17; 2 -> T1; 2 -> 18;
    10 -> 11; 10 -> 14; 10 -> T1; 10 -> 13; 10 -> 12;
    31 -> T1; 31 -> 32; 33 -> T30; 33 -> 34; 42 -> 4; 26 -> 4;
    3 -> 4; 16 -> 15; 17 -> 19; 18 -> 29; 11 -> 4; 14 -> 15;
    37 -> 39; 37 -> 41; 37 -> 38; 37 -> 40; 13 -> 19; 12 -> 29;
    43 -> 38; 43 -> 40; 36 -> 19; 32 -> 23; 34 -> 29; 39 -> 15;
    41 -> 29; 38 -> 4; 40 -> 19; 4 -> 5; 19 -> 21; 19 -> 20;
    19 -> 28; 5 -> 6; 5 -> T35; 5 -> 23; 21 -> 22; 20 -> 15; 28 -> 29;
    6 -> 7; 15 -> T1; 22 -> 23; 22 -> T35; 29 -> T30; 7 -> T8;
    23 -> T24; 23 -> T1;
}
~~~
> 图 1-2a(用时1.11秒, Sun-4/280)

~~~dot
digraph shells {
    size="7,8";
    node [fontsize=24, shape = plaintext];
    1972 -> 1976 -> 1978 -> 1980 -> 1982 -> 1984 -> 1986 -> 1988
        -> 1990 -> future;
    node [fontsize=20, shape = box];
    { rank = same;  1976 Mashey Bourne; }
    { rank = same;  1978 Formshell csh; }
    { rank = same;  1980 esh vsh; }
    { rank = same;  1982 ksh "System-V"; }
    { rank = same;  1984 v9sh tcsh; }
    { rank = same;  1986 "ksh-i"; }
    { rank = same;  1988 KornShell Perl rc; }
    { rank = same;  1990 tcl Bash; }
    { rank = same;  "future" POSIX "ksh-POSIX"; }
    Thompson -> {Mashey Bourne csh}; csh -> tcsh;
    Bourne -> {ksh esh vsh "System-V" v9sh}; v9sh -> rc;
           {Bourne "ksh-i" KornShell} -> Bash;
    {esh vsh Formshell csh} -> ksh;
    {KornShell "System-V"} -> POSIX;
    ksh -> "ksh-i" -> KornShell -> "ksh-POSIX";
    Bourne -> Formshell;
    /* ’invisible’ edges to adjust node placement */
    edge [style=invis];
    1984 -> v9sh -> tcsh ; 1988 -> rc -> KornShell;
    Formshell -> csh; KornShell -> Perl;
}
~~~
> 图1-3a. (用时0.5秒，Sun-4/28)

## 2 最优层级分配

第一步为图G中所有节点n根据其边分配一个整数层级λ(v)。
这意味着每一个 e=(v, w)成员 E, l(e)>=δ(e)，e=(v,w)的长度l(e)被定义为λ(w)− λ(v)
并且δ(e)描述了一些给定最小长度限制δ(e)，通常为1， 但可以取值为任何非负整数。
δ(e)可以被内部设定，如果用户需要调整等级分配。在这一步，任何非空集合Smax, Smin, S0, ..., Sk 会被暂时合并为一个节点。
环会被忽略，多边会被合并为单个边，其权重是被合并边的权重合。
为了提高效率，不是以上集合中的叶子节点会被忽略，这些叶子节点的权重会被琐碎的确定为最佳排行。

### 2.1 消除图中的环

图必须是无环的才能获得一致的等级分配。由于输入的途中可能包含环，就需要一个预处理步骤来发现并通过翻转一些边来消除环[RDM]。
这些边只会在内部被翻转；箭头在绘制时还会按照原本的方向。有效的消环方法可以基于深度优先搜索。
边会根据输入的图从某些source节点或者sink节点以"自然顺序"被搜索。
深度优先搜索会将边分为两类: 树的边或者非树的边[AHU]。树定义了节点的部分有序。
基于这种部分有序，非树边进一步被分为了三类: 交叉边(cross edge)，前向边(forward edge)，后向边(back edge)。
交叉边按部分顺序连接无关的节点。前向边连接节点和他的一些后代。后向边连接了节点和它的祖先。
显然前向边和交叉边在部分有序中不会创建环。通过翻转后向边，使它们成为前向边，这种方式可以消除所有的环。

尝试翻转较小的一组边看似合理。但困难在于找到最小集("反馈弧集"问题)是NP完全的[EMW][GJ]。
更重要的是这可能并不能改善绘图的效果。我们实现了启发式算法来翻转同时参与多个环的边。
该算法一次以任意顺序获取一个non-trivial强连接边。计算那个边沿深度优先遍历形成环的次数。
最大计数的边将会被翻转。不断重复该过程，知道不再有这样特例连接的边为止。

对这种启发式算法进行的实验表明，即使包含环，实际应用中大多数有向图也具有自然的总边缘方向。
图输入通常会呈现这种自然的方向性。翻转不恰当的边会干扰正常的绘制。
例如，即使过程调用图具有循环，仍然希望在图的顶部而不是中间看到顶层函数。
从稳定性角度来看，深度优先，启发式破环方法似是最优选择。

如多数研究人员建议的那样，这样可以获得的信息多于折叠环上所有节点为单个节点，或者置环上所有节点为相同的层级，或者复制环上的一个节点，

另一个细节在于代表Smax和Smin的节点必须始终具有最大和最小的等级分配。
通过翻转Smax和Smin的边缘来确保此属性。
同样对于所有没有入边的节点v，设定一个临时边(Smin, v)，令其δ=0。
对于所有的没有出边的节点v，设定一个临时边(v, Smax)，令其δ=0。
于是，对于所有的v存在 λ(Smin) ≤ λ(v) ≤ λ(Smax) 

### 2.2 问题定义

原则A3规定设定的短边。除了制作更好的布局之外，短边还能缩短取决于总边长的later passes的时间。
因此，需要找到一个最优的节点排名，即所有加权边缘长度值和最小的节点排名。
寻找最佳排名可以被描述为以下的整数程序: 

...

如前所述，权重函数ω和最小长度函数δ分别将边缘E映射为非负有理数和非负整数。


有多种方法可以在多项式时间内求解此整数程序。
一种方法是求解等价线性程序，在多项式时间内将其转换为整数。
另一个涉及将最优等级分配问题转换为最小成本流动或循环问题，词类问题存在多项式时间算法(参考[GT])。
由于约束矩阵是完全单模的，因此通过单纯型算法也可以解决问题，尽管不一定在多项式时间内。
[GNV2]中将对这些技术进行更多讨论。

## 2.3 网络单纯型(Network simplex)

这里我们叙述最简单的基于网络单纯型算法的公式[Ch]。























